package darecreek.vfuAutotest.fullPipeline

import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec
import chisel3._
import chiseltest.WriteVcdAnnotation
import scala.reflect.io.File
import scala.reflect.runtime.universe._

import darecreek.exu.vfu._
import darecreek.exu.vfu.alu._
import darecreek.exu.vfu.vmask._
import darecreek.exu.vfu.reduction._
import darecreek.exu.vfu.VInstructions._

class RedTestEngine extends TestEngine {

    override def getName() = "RedTestEngine"
    override def getDut() = new Reduction


    override def iterate(
        dut : Reduction, chosenTestCase : TestCase, 
        sendRobIdx : Int, allExhausted : Boolean, 
        flush : Boolean, flushedRobIdx : Int
    ) : (Boolean, Int) = {
        
        val (input, uopIdx) : (VFuInput, Int) = chosenTestCase.nextVfuInput((true, sendRobIdx))
        println(s"Sending ${chosenTestCase.instid}, uop ${uopIdx}, robIdx ${sendRobIdx}")

        // ===================== manipulating dut ========================
        if(!allExhausted) {
            dut.io.in.valid.poke(true.B)

            dut.io.in.bits.poke(input)
            if (flush) {
                dut.io.redirect.poke(genFSMRedirect((flush, flush, flushedRobIdx)))
            } else {
                dut.io.redirect.poke(genFSMRedirect())
            }
            dut.clock.step(1)
        }

        val dutVd = dut.io.out.bits.vd.peek().litValue
        val dutVxsat = dut.io.out.bits.vxsat.peek().litValue == 1

        // TODO 1.3. check for potential results, get the comparison result
        val resCorrectness = chosenTestCase.rc.checkRes(dutVd, uopIdx, dutVxsat=dutVxsat)
        val resRobIdx = sendRobIdx

        return (resCorrectness, resRobIdx)
    }

}