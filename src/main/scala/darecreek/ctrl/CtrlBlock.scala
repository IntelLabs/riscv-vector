/***************************************************************************************
*Copyright (c) 2023-2024 Intel Corporation
*Vector Acceleration IP core for RISC-V* is licensed under Mulan PSL v2.
*You can use this software according to the terms and conditions of the Mulan PSL v2.
*You may obtain a copy of Mulan PSL v2 at:
*        http://license.coscl.org.cn/MulanPSL2
*THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
*EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
*MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
*See the Mulan PSL v2 for more details.
***************************************************************************************/

package darecreek

import chisel3._
import chisel3.util._
import utils._

class PartialVInfo extends Bundle {
  val vRobPtr = new VRobPtr
  val destEew = UInt(3.W)
  val emulVd = UInt(4.W)
  val emulVs2 = UInt(4.W)
}

class VCtrlBlock extends Module {
  val io = IO(new Bundle {
    // OVI issue
    val ovi_issue = new OVIissue
    // OVI dispatch
    val ovi_dispatch = new OVIdispatch
    // OVI completed
    val ovi_completed = new OVIcompleted
    // Dispatch outputs
    val out = new Bundle {
      val toArithIQ = Vec(VRenameWidth, Decoupled(new VExpdUOp))
      val toLdIQ = Vec(VRenameWidth, Decoupled(new VExpdUOp))
      val toStaIQ = Vec(VRenameWidth, Decoupled(new VExpdUOp))
      // val toStdIQ = Vec(VRenameWidth, Decoupled(new VExpdUOp))
    }
    // writeback: to update busyTable, to ROB
    val wbArith = Flipped(ValidIO(new WbArith))
    val wbLSU = Vec(2, Flipped(ValidIO(new VExpdUOp)))
    val readBusyTable = Vec(VRenameWidth, Vec(4, Output(Bool())))
    // rs1 read requests from issue queues
    val get_rs1 = Flipped(new GetScalarOperand)
    // flush generated by ROB
    val flush = Output(Bool())
    // Just for debug
    val commits = new VRobCommitIO
    val rvfi_sb_id = Output(UInt(5.W))
    val commitEnd = Output(Bool())
  })

  val decoder = Module(new VDecodeUnit)
  val infoCalc = Module(new VInfoCalc)
  val vq = Module(new VecQueue)
  val expander = Module(new ParallelExpander)
  val rat = Module(new VRenameTableWrapper)
  val rename = Module(new VRename)
  val busyTable = Module(new VBusyTable(VRenameWidth * 4, NArithIQs + 1))
  val dispatch = Module(new VDispatch)
  val rob = Module(new VRob)

  val flush = rob.io.flush.valid
  io.flush := flush

  // decode
  decoder.io.in <> io.ovi_issue
  decoder.io.issueCredit := rob.io.ovi_issueCredit

  // infoCalc
  infoCalc.io.ctrl := decoder.io.out.bits.ctrl
  infoCalc.io.csr := decoder.io.out.bits.csr
  val partialVInfo_reg = Reg(ValidIO(new PartialVInfo))
  when (decoder.io.out.valid) {
    partialVInfo_reg.bits.destEew := infoCalc.io.infoAll.veewVd
    partialVInfo_reg.bits.emulVd := infoCalc.io.infoAll.emulVd
    partialVInfo_reg.bits.emulVs2 := infoCalc.io.infoAll.emulVs2
    partialVInfo_reg.bits.vRobPtr := vq.io.enqPtrOut
  }
  partialVInfo_reg.valid := decoder.io.out.valid
  
  // vq
  vq.io.in := decoder.io.out
  vq.io.flush := rob.io.flush
  vq.io.get_rs1 <> io.get_rs1

  PipelineConnect(vq.io.out, expander.io.in(0), expander.io.in(0).ready, isFlush = flush)
  // Temp: disable the second input of expander
  expander.io.in(1).valid := false.B
  expander.io.in(1).bits := 0.U.asTypeOf(new VMicroOp)
  for (i <- 0 until VRenameWidth) {
    PipelineConnect(expander.io.out(i), rename.io.in(i), rename.io.in(i).ready, isFlush = flush)
    PipelineConnect(rename.io.out(i), dispatch.io.in(i), dispatch.io.in(i).ready, isFlush = flush)
  }

  // Rename Table
  for ((r, i) <- rat.io.readPorts.zipWithIndex) {
    r(0).addr := expander.io.out(i).bits.lsrcExpd(0)
    r(1).addr := expander.io.out(i).bits.lsrcExpd(1)
    r(2).addr := expander.io.out(i).bits.ldestExpd
    r(3).addr := 0.U
    rename.io.ratReadPorts(i) := r.map(_.data)
    r.foreach(_.hold := !rename.io.in(i).ready)
  }
  rat.io.renamePorts := rename.io.ratWritePorts
  rat.io.robCommits := rob.io.commits
  rat.io.flush := flush

  // Rename
  rename.io.flush := flush
  rename.io.robCommits := rob.io.commits

  dispatch.io.flush := flush

  io.out <> dispatch.io.out
  busyTable.io.allocPregs := rename.io.allocPregs
  //read busyTable : 4 + 4 + 4 + ... + 4
  for (i <- 0 until VRenameWidth * 4) {
    busyTable.io.read(i).req := dispatch.io.readBusyTable(i / 4)(i % 4)
    io.readBusyTable(i / 4)(i % 4) := busyTable.io.read(i).resp
  }
  for (i <- 0 until NArithIQs) {
    busyTable.io.wbPregs(i).valid := io.wbArith.valid && io.wbArith.bits.uop.pdestVal
    busyTable.io.wbPregs(i).bits := io.wbArith.bits.uop.pdest
  }
  busyTable.io.wbPregs(NArithIQs).valid := io.wbLSU(0).valid && io.wbLSU(0).bits.pdestVal
  busyTable.io.wbPregs(NArithIQs).bits := io.wbLSU(0).bits.pdest
  busyTable.io.flush := flush

  // Illegal instrn module
  val vIllegalInstrn = Module(new VIllegalInstrn)
  vIllegalInstrn.io.validIn := decoder.io.out.valid
  vIllegalInstrn.io.ctrl := decoder.io.out.bits.ctrl
  vIllegalInstrn.io.csr := decoder.io.out.bits.csr
  vIllegalInstrn.io.infoAll := infoCalc.io.infoAll
  vIllegalInstrn.io.extraInfo_for_VIllegal := infoCalc.io.extraInfo_for_VIllegal
  vIllegalInstrn.io.robPtrIn := vq.io.enqPtrOut
  vq.io.illegal := vIllegalInstrn.io.ill
  vq.io.partialVInfo := partialVInfo_reg

  // ROB
  rob.io.in.valid := decoder.io.out.valid
  rob.io.in.sb_id := decoder.io.out.bits.sb_id
  rob.io.in.ldestVal := decoder.io.out.bits.ctrl.ldestVal
  rob.io.in.rdVal := decoder.io.out.bits.ctrl.rdVal
  rob.io.ovi_dispatch := io.ovi_dispatch
  rob.io.illegal := vIllegalInstrn.io.ill
  rob.io.partialVInfo := partialVInfo_reg
  rob.io.fromDispatch <> dispatch.io.toRob
  rob.io.wbArith := io.wbArith
  rob.io.wbLSU := io.wbLSU
  io.ovi_completed := rob.io.ovi_completed


  /**
    *  Debug
    */
  io.commits := rob.io.commits
  io.rvfi_sb_id := rob.io.rvfi_sb_id
  io.commitEnd := rob.io.commitEnd
}