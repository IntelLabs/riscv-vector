/** Integer and fixed-point (except mult and div)
  *   
  * Perform below instructions:
  *     11.1  vadd, ...
  *     11.2  vwadd, ...
  *     11.3  vzext, ... //Todo: move to crosslane block
  *     11.4  vadc, vmadc, ...
  *     11.5  vand, ...
  *     11.6  vsll, ...
  *     11.7  vnsrl, ...
  *     11.8  vmseq, vmsltu, ...
  *     11.9  vminu, ...
  *     11.15 vmerge
  *     11.16 vmv.v.
  *     12.1  vsadd, ...
  *     12.2  vaadd, ...
  *     12.4  vssrl, ...
  *     12.5  vnclip, ...
  *     16.1
  *     16.2
  *     16.6
  */
package darecreek.exu.lanevfu.alu

import chisel3._
import chisel3.util._
import chisel3.util.experimental.decode._
import chipsalliance.rocketchip.config._
import darecreek.exu.vfu.alu._

class VIntFixpDecode extends Bundle {
  val sub = Bool()
  val misc = Bool()
  val fixp = Bool()
}

class LaneVAlu extends Module {
  val io = IO(new Bundle {
    val in = Flipped(Decoupled(new LaneFUInput))
    val mask_ori = Input(UInt(NByteLane.W))
    val out = Decoupled(new LaneFUOutput)
  })

  io.in.ready := true.B
  val valid = io.in.valid
  val uop = io.in.bits.uop
  val (funct6, funct3) = (uop.ctrl.funct6, uop.ctrl.funct3)
  val (vm, vs1_imm) = (uop.ctrl.vm, uop.ctrl.lsrc(0))
  val (widen, widen2) = (uop.ctrl.widen, uop.ctrl.widen2)
  val (narrow, narrow_to_1) = (uop.ctrl.narrow, uop.ctrl.narrow_to_1)
  val (uopIdx, uopEnd) = (uop.expdIdx, uop.expdEnd)
  val sew = SewOH(uop.info.vsew)
  val (ma, ta) = (uop.info.ma, uop.info.ta)
  val (vl, vstart) = (uop.info.vl, uop.info.vstart)
  val oldVd = io.in.bits.old_vd
  val vs2 = io.in.bits.vs2
  val vmask = io.mask_ori
  //                                |sign-extend imm to 64 bits|
  val rs1Imm = Mux(uop.ctrl.vi, vs1_imm.asSInt.pad(XLEN).asUInt, io.in.bits.rs1)
  val rs1Imm_repeat = Mux1H(sew.oneHot, Seq(8, 16, 32, 64).map(n => Fill(64/n, rs1Imm(n-1, 0))))
  val vs1 = Mux(uop.ctrl.vv, io.in.bits.vs1, rs1Imm_repeat)
  // EEW of Vd (exclude narrow_to_1)
  val veewVd = uop.info.vsew + Mux(widen || widen2, 1.U, 0.U)
  val eewVd = SewOH(veewVd)

  val truthTable = TruthTable(VAluTable.table, VAluTable.default)
  val opi = funct3(0) === funct3(1)
  val decoderOut = decoder(QMCMinimizer, Cat(funct6, opi), truthTable)
  val vIntFixpDecode = decoderOut.asTypeOf(new VIntFixpDecode)

  isSub := vIntFixpDecode.sub
  isMisc := vIntFixpDecode.misc
  isFixp := vIntFixpDecode.fixp

  val vIntAdder64b = Module(new VIntAdder64b)
  vIntAdder64b.io.funct6 := funct6 
  vIntAdder64b.io.vm := vm
  vIntAdder64b.io.ma := ma
  vIntAdder64b.io.sew := sew
  vIntAdder64b.io.eewVd := eewVd
  vIntAdder64b.io.uopIdx := uopIdx
  vIntAdder64b.io.vs1 := vs1
  vIntAdder64b.io.vs2 := vs2
  vIntAdder64b.io.oldVd := oldVd
  vIntAdder64b.io.vmask := vmask
  vIntAdder64b.io.isSub := isSub
  vIntAdder64b.io.widen := widen
  vIntAdder64b.io.widen2 := widen2
  vIntAdder64b.io.narrow_to_1 := narrow_to_1
  
  val vIntMisc64b = Module(new VIntMisc64b)
  vIntMisc64b.io.funct6 := funct6 
  vIntMisc64b.io.funct3 := funct3 
  vIntMisc64b.io.vi := vi
  vIntMisc64b.io.vm := vm
  vIntMisc64b.io.vs1_imm := vs1_imm
  vIntMisc64b.io.narrow := narrow
  vIntMisc64b.io.sew := sew
  vIntMisc64b.io.uopIdx := uopIdx
  vIntMisc64b.io.vs1 := vs1
  vIntMisc64b.io.vs2 := vs2
  vIntMisc64b.io.vmask := vmask
  
  val vdAdderS1 = RegEnable(vIntAdder64b.io.vd, valid)
  val vdMiscS1 = RegEnable(vIntMisc64b.io.vd, valid)
  val isMiscS1 = RegEnable(isMisc, valid)
  val narrowVdMiscS1 = RegEnable(vIntMisc64b.io.narrowVd, valid)
  val cmpOutS1 = RegEnable(vIntAdder64b.io.cmpOut, valid)
  val isFixpS1 = RegEnable(isFixp, valid)
  
  val vFixPoint64b = Module(new VFixPoint64b)
  vFixPoint64b.io.funct6 := RegEnable(funct6, valid)
  vFixPoint64b.io.sew := RegEnable(sew, valid)
  vFixPoint64b.io.vxrm := RegEnable(vxrm, valid)
  vFixPoint64b.io.isFixp := RegEnable(isFixp, valid)
  vFixPoint64b.io.isSub := RegEnable(isSub, valid)
  vFixPoint64b.io.fromAdder := RegEnable(vIntAdder64b.io.toFixP, valid)
  vFixPoint64b.io.fromMisc := RegEnable(vIntMisc64b.io.toFixP, valid)

  vd_out := Mux(isFixpS1, vFixPoint64b.io.vd, Mux(isMiscS1, vdMiscS1, vdAdderS1))
  narrowVd_out := Mux(isFixpS1, vFixPoint64b.io.narrowVd, narrowVdMiscS1)
  cmpOut_out := cmpOutS1
  vxsat_out := vFixPoint64b.io.vxsat
  rd_out := RegEnable(vIntMisc64b.io.rd, valid)

  /**
   * Output stage
   */
  val validS1 = RegNext(valid)
  val funct6_S1 = RegEnable(funct6, valid)
  val opi_S1 = RegEnable(opi, valid)
  val uopIdxS1 = RegEnable(uopIdx, valid)
  val old_vd_S1 = Wire(UInt(64.W))
  old_vd_S1 := RegEnable(oldVd, valid)
  val eewVs1S1 = RegEnable(sew, valid)
  val eewVdS1 = RegEnable(eewVd, valid)
  val narrowS1 = RegEnable(narrow, valid)
  val cmpFlagS1 = RegEnable(eewVd_is_1b, valid) // Compare and carry-out
  val vmS1 = RegEnable(vm, valid)
  val taS1 = RegEnable(ta, valid)
  val maS1 = RegEnable(ma, valid)
  val mask16bS1 = RegEnable(mask16b, valid)
  val vl_S1 = RegEnable(vl, valid)
  val vstartS1 = RegEnable(vstart, valid)
  //---- Narrowing vd rearrangement ----
  val narrowVd_out_reg = RegEnable(narrowVd_out, validS1 && !uopIdxS1(0))
  val vdOfNarrow = Mux(uopIdxS1(0), Cat(narrowVd_out, narrowVd_out_reg),
                       Cat(0.U(32.W), narrowVd_out))
  //---- Compare/carry-out vd rearrangement ----
  // val cmpOut128b = Mux1H(eewVs1S1.oneHot, Seq(8,4,2,1).map(
                    // k => Cat(0.U((128-2*k).W), cmpOuts(1)(k-1,0), cmpOuts(0)(k-1,0))))
  val cmpOut = Mux1H(eewVs1S1.oneHot, Seq(8,4,2,1).map(
                    k => Cat(0.U((64-k).W), cmpOut_out(k-1,0))))
  // val cmpOutOff128b = Mux1H(eewVs1S1.oneHot, Seq(8,4,2,1).map(
                    // k => Cat(0.U((128-2*k).W), ~0.U((2*k).W))))
  val cmpOutOff = Mux1H(eewVs1S1.oneHot, Seq(8,4,2,1).map(
                    k => Cat(0.U((64-k).W), ~0.U(k.W))))
  val shiftCmpOut = Wire(UInt(6.W))
  shiftCmpOut := Mux1H(eewVs1S1.oneHot, Seq(4,3,2,1).map(i => uopIdxS1(2, 0) << i))
  val cmpOutKeep = Wire(UInt(128.W))
  cmpOutKeep := cmpOut128b << shiftCmpOut
  val cmpOutOff = Wire(UInt(128.W))
  cmpOutOff := ~(cmpOutOff128b << shiftCmpOut)
  // val cmpOutResult = old_vd_S1 & cmpOutOff | cmpOutKeep // Compare and carry-out instrns

  /** Change cmpOutResult generation: 
   *    use a internal register to hold last compare-out
   */
  val old_cmpOutResult = Reg(UInt(128.W))
  val cmpOutResult = old_cmpOutResult & cmpOutOff | cmpOutKeep // Compare and carry-out instrns
  val uopEndS1 = RegEnable(uopEnd, valid)
  when (validS1) {
    old_cmpOutResult := Mux(uopEndS1, 0.U, cmpOutResult)
  }
  io.out.valid := RegNext(Mux(narrow, (uopIdx(0) || uopEnd) && valid,
                          Mux(narrow_to_1, uopEnd && valid, valid)), init = false.B)

  /**
   * Output tail/prestart/mask handling for eewVd >= 8
   */
  //---- evl (for Whole Reg Move) ----
  val evl = Wire(UInt(bVL.W)) // Only used for whole reg move
  val nreg = vs1_imm(2, 0) +& 1.U  // emul = nreg, nreg = simm[2:0] + 1
  val vlen_div_sew = Mux1H(sew.oneHot, Seq(1,2,4,8).map(k => (VLENB / k).U))
  evl := Mux1H(Seq( // EMUL*VLEN/SEW
    (nreg === 1.U) -> vlen_div_sew,
    (nreg === 2.U) -> (vlen_div_sew << 1),
    (nreg === 4.U) -> (vlen_div_sew << 2),
    (nreg === 8.U) -> (vlen_div_sew << 3)
  ))
  val isWholeRegMv = funct6 === "b100111".U && funct3 === "b011".U
  //---- Tail gen ----
  val isPermVmv = funct6 === "b010000".U && !opi
  val tail = TailGen(Mux(isPermVmv, 1.U, Mux(isWholeRegMv, evl, vl)), uopIdx, eewVd, narrow)
  // val tail = TailGen(vl, uopIdx, eewVd, narrow)
  val tailS1 = RegEnable(tail, valid)
  //---- Prestart gen ----
  // val prestart = PrestartGen(vstart, uopIdx, Mux(narrow, eewVs2, eewVd))
  val prestart = PrestartGen(vstart, uopIdx, eewVd, narrow)
  val prestartS1 = RegEnable(prestart, valid)
  //---- vstart >= vl ----
  val vstart_gte_vl = Mux(isWholeRegMv, vstart >= evl, vstart >= vl)
  val vstart_gte_vl_S1 = RegEnable(vstart_gte_vl, valid)

  val tailReorg = MaskReorg.splash(tailS1, eewVdS1)
  val prestartReorg = MaskReorg.splash(prestartS1, eewVdS1)
  val mask16bReorg = MaskReorg.splash(mask16bS1, eewVdS1)
  val updateType = Wire(Vec(16, UInt(2.W))) // 00: keep result  10: old_vd  11: write 1s
  for (i <- 0 until 16) {
    when (prestartReorg(i) || vstart_gte_vl_S1) {
      updateType(i) := 2.U
    }.elsewhen (tailReorg(i)) {
      updateType(i) := Mux(taS1, 3.U, 2.U)
    // }.elsewhen (opcodeS1.isAddWithCarry || opcodeS1.isVmerge) {
    }.elsewhen (funct6_S1(5,2) === "b0100".U && opi_S1 || funct6_S1 === "b010111".U && !vmS1) {
      updateType(i) := 0.U
    }.elsewhen (!vmS1 && !mask16bReorg(i)) {
      updateType(i) := Mux(maS1, 3.U, 2.U)
    }.otherwise {
      updateType(i) := 0.U
    }
  }
  // finalResult = result & bitsKeep | bitsReplace   (all are 128 bits)
  val bitsKeep = Cat(updateType.map(x => Mux(x(1), 0.U(8.W), ~0.U(8.W))).reverse)
  val bitsReplace = Cat(updateType.zipWithIndex.map({case (x, i) => 
        Mux(!x(1), 0.U(8.W), Mux(x(0), ~0.U(8.W), UIntSplit(old_vd_S1, 8)(i)))}).reverse)

  /**
   * Output tail/prestart/mask handling for eewVd == 1
   */
  val tail_1b_temp = UIntToCont0s(vl_S1(bVL-2, 0), bVL-1)
  require(tail_1b_temp.getWidth == 128)
  val tail_1b = Mux(vl_S1 === 128.U, 0.U(128.W), tail_1b_temp)
  val prestart_1b = UIntToCont1s(vstartS1, bVSTART)
  require(prestart_1b.getWidth == 128)
  val bitsKeep_1b = ~(prestart_1b | tail_1b)
  val bitsReplace_1b = Mux(vstart_gte_vl_S1, old_vd_S1, 
                       prestart_1b & old_vd_S1 | tail_1b)

  val bitsKeepFinal = Mux(cmpFlagS1, bitsKeep_1b, bitsKeep)
  val bitsReplaceFinal = Mux(cmpFlagS1, bitsReplace_1b, bitsReplace)

  val vdResult = Mux(narrowS1, vdOfNarrow, 
              Mux(cmpFlagS1, cmpOutResult, Cat(vIntFixpAlu64bs.map(_.io.vd).reverse)))
  io.out.bits.vd := Mux(vIntFixpAlu64bs(0).io.rd.valid, vIntFixpAlu64bs(0).io.rd.bits,
                        vdResult & bitsKeepFinal | bitsReplaceFinal)
  when (!narrowS1) {
    io.out.bits.vxsat := (Cat(vIntFixpAlu64bs.map(_.io.vxsat).reverse) &
                     Cat(updateType.map(_(1) === false.B).reverse)).orR
  }.otherwise {
    io.out.bits.vxsat := (Cat(vIntFixpAlu64bs.map(_.io.vxsat(VLENB/4 - 1, 0)).reverse) &
                     Mux(uopIdxS1(0), Cat(updateType.drop(VLENB/2).map(_(1) === false.B).reverse),
                                      Cat(updateType.take(VLENB/2).map(_(1) === false.B).reverse))
                     ).orR
  }
}


import xiangshan._
object Main extends App {
  println("Generating hardware")
  val p = Parameters.empty.alterPartial({case XSCoreParamsKey => XSCoreParameters()})
  emitVerilog(new VAlu()(p.alterPartial({case VFuParamsKey => VFuParameters()})), Array("--target-dir", "generated",
              "--emission-options=disableMemRandomization,disableRegisterRandomization"))
}